using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MoonCore.PluginFramework.Generator;

[Generator]
public class SrcGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterSourceOutput(context.CompilationProvider, (productionContext, compilation) =>
        {
            var pluginLoaderClasses = AnalyzeHelper
                .GetTypesFromAssembly(compilation.Assembly)
                .Where(x => x.TypeKind == TypeKind.Class)
                .Where(x => x.Interfaces.Length == 1) // TODO: Optimize query
                .Where(x => x.GetAttributes().Any(attr =>
                        attr.AttributeClass?.Name == "PluginLoaderAttribute" ||
                        attr.AttributeClass?.ContainingNamespace.ToDisplayString() == "MoonCore.PluginFramework"
                    )
                );

            var externalReferencedClasses = AnalyzeHelper
                .GetExternalTypes(compilation.SourceModule)
                .Where(x => x.TypeKind == TypeKind.Class)
                .ToArray();
            
            foreach (var plClass in pluginLoaderClasses)
            {
                // Handle invalid symbols
                if(plClass is not INamedTypeSymbol pluginLoaderClass)
                    continue;
                
                // Search for plugin interface
                var pluginInterface = pluginLoaderClass.Interfaces[0];

                var allImplementations = new List<INamedTypeSymbol>();
                
                // Search for internal implementations
                foreach (var tree in compilation.SyntaxTrees)
                {
                    var semanticModel = compilation.GetSemanticModel(tree);
                    
                    var classNodes = tree
                        .GetRoot()
                        .DescendantNodes()
                        .OfType<ClassDeclarationSyntax>();

                    foreach (var classNode in classNodes)
                    {
                        var symbol = semanticModel.GetDeclaredSymbol(classNode) as INamedTypeSymbol;
                        
                        // Dont handle invalid symbols
                        if(symbol == null)
                            continue;

                        // Ignore the loader class itself
                        if (SymbolEqualityComparer.Default.Equals(symbol, pluginLoaderClass))
                            continue;
                        
                        // If the class doesn't implement the interface we want to continue 
                        if(!symbol.AllInterfaces.Contains(pluginInterface, SymbolEqualityComparer.Default))
                            continue;
                        
                        allImplementations.Add(symbol);
                    }
                }

                // Search for external implementations
                foreach (var externalReferencedClass in externalReferencedClasses)
                {
                    if(externalReferencedClass is not INamedTypeSymbol symbol)
                        continue;
                    
                    // Ignore the loader class itself
                    if (SymbolEqualityComparer.Default.Equals(symbol, pluginLoaderClass))
                        continue;
                        
                    // If the class doesn't implement the interface we want to continue 
                    if(!symbol.AllInterfaces.Contains(pluginInterface, SymbolEqualityComparer.Default))
                        continue;
                        
                    allImplementations.Add(symbol);
                }
                
                var sourceText = GeneratePartialClass(pluginLoaderClass, pluginInterface, allImplementations);
                productionContext.AddSource($"{pluginLoaderClass.Name}_PluginLoader.g.cs", SourceText.From(sourceText, Encoding.UTF8));
            }
        });
    }

    private static string GeneratePartialClass(INamedTypeSymbol loaderClass, INamedTypeSymbol interfaceType, List<INamedTypeSymbol> implementations)
    {
        var ns = loaderClass.ContainingNamespace.ToDisplayString();
        var className = loaderClass.Name;
        var interfaceName = interfaceType.ToDisplayString();
        
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {className}");
        
        // Declare the instances
        
        sb.AppendLine("    {");
        sb.AppendLine($"        public {interfaceName}[] Instances {{ get; private set; }}");
        
        // Create references to them when initializing
        
        sb.AppendLine($"        public void Initialize()");
        sb.AppendLine("        {");
        sb.AppendLine($"            Instances = new {interfaceName}[]");
        sb.AppendLine("            {");

        foreach (var impl in implementations.Distinct(SymbolEqualityComparer.Default))
        {
            sb.AppendLine($"                new {impl.ToDisplayString()}(),");
        }

        sb.AppendLine("            };");
        sb.AppendLine("        }");
        
        // Now we want to implement all the interface methods in our partial class and proxy them to all instances

        foreach (var method in interfaceType.GetMembers().OfType<IMethodSymbol>())
        {
            if (method.MethodKind != MethodKind.Ordinary)
                continue;

            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;
            var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
            var args = string.Join(", ", method.Parameters.Select(p => p.Name));

            
            if(returnType == "System.Threading.Tasks.Task")
                sb.AppendLine($"        public async {returnType} {methodName}({parameters})");
            else
                sb.AppendLine($"        public {returnType} {methodName}({parameters})");
            
            sb.AppendLine("        {");

            if (returnType != "void" && returnType != "System.Threading.Tasks.Task")
            {
                sb.AppendLine($"            {returnType} result = default;");
            }

            sb.AppendLine("            foreach (var instance in Instances)");
            sb.AppendLine("            {");

            if (returnType != "void")
            {
                if(returnType == "System.Threading.Tasks.Task")
                    sb.AppendLine($"                await instance.{methodName}({args});");
                else
                    sb.AppendLine($"                result = instance.{methodName}({args});");
            }
            else
                sb.AppendLine($"                instance.{methodName}({args});");

            sb.AppendLine("            }");

            if (returnType != "void" && returnType != "System.Threading.Tasks.Task")
                sb.AppendLine("            return result;");

            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}